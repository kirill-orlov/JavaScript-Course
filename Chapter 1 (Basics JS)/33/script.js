"use strict";

const arr = [11, 15, 3, 6, 18];

arr.sort(compareNum);
console.log(arr);

function compareNum(a, b) {
    return a-b;
}

// arr[99] = 0;
// console.log(arr.length); // 100 (потому что - последний индекс + 1)

// Логичный вопрос: а когда использовать forEach, а когда цикл for of? Обычно, программисты используют forEach, но плюс метода for of в том, что мы можем использовать break и continue

arr.forEach(function(item, i, arr) {
    console.log(`${i}: ${item} внутри массива ${arr}`);
}); // Похож на методы перебора массива через циклы, но более гибко настраивается. Также здесь у нас колбэк функция, она может принимать в себя 3 параметра: 1) Значение элемента 2) Номер этого элемента 3) Массив

//.shift, //unshift - редко используются
// arr.pop(); // Удаление последнего элемента массива
// arr.push(10); //Добавление элементов в конец массива

// Варианты перебора массива (2 релевантнее)
for (let i = 0; i < arr.length; i++) {
    console.log(arr[i]);
}

// Конструкция of работает только с массивоподобными сущностями: массивы, псевдомассивы, строки, map и set
for (let value of arr) {
    console.log(value);
}

const str = prompt("", "");
const products = str.split(", "); //Сформировать массив, разделив полученную строку
// console.log(products);
products.sort(); // Сортировка элементов КАК СТРОК. Посимвольно (быстрая сортировка) (16, 18, 2, 21, 22, 3)
console.log(products.join("; ")); // Обратно склеиваем массив в строку. Объедининение элементов массива в строку

// Когда мы работаем с элементами на странице, мы получаем псевдомассивы. Э
// Это такие объекты, структура которых совпадает со структурой объекта. Но по сути, это не массивы. А значит, к ним не применимы методы для работы с массивами (forEach, push, pop, join.. etc)
